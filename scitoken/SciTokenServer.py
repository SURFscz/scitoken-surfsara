import scitokens
import subprocess
import requests
from cryptography.hazmat.primitives.asymmetric.rsa import generate_private_key
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

from scitoken.models import OAuth2RefreshToken, User, db


# NOTES
# The flow is the following:
# 1. You generate a base token with generateBaseSciToken() which
#    will generate a Scitoken after generating a private key
# 2. Then generate a normal token by using the relevant base token.
#    Since the tokens can be chained, the relevant permission hierarchies
#    must be taken into consideration...

# Parent Tokens:
# The tokens can also be chained, i.e. one token can be appended to another.
# By default the new token will default to having all the authorisations of the parent token
# but is mutable and can add further restrictions. Parent tokens are typically generated by a
# separate server and sent as a response to a successful authentication or authorization request
#
# Refresh Tokens:
# The generation of the refresh token will be done according to OAuth2 spec : https://tools.ietf.org/html/rfc6749#section-1.5
# We use authlib of Flask for OAuth2 related functionality.
# The flow here is : An authorization code flow is executed to obtain an authorization code. The authorization code
# then is used to get an access + refresh token...




class TokenManager():

    # TODO : Check the Scitoken implementation in the coming months to see their RefreshToken feature is implemented
    # Note: There are different views: refresh tokens never expire or they have an expiry time/date...
    def addRefreshToken(self, username, refresh_token, scope=None,access_token=None,expires_in = None):
        '''
        :param username:
        :param refresh_token:
        :param scope:
        :param access_token:
        :param expires_in:
        :return:
        '''
        rtoken = OAuth2RefreshToken(user_id=User.query.filter_by(username=username).first().id)
        rtoken.refresh_token = refresh_token
        rtoken.scope = scope
        rtoken.access_token = access_token
        rtoken.expires_in = expires_in
        db.session.add(rtoken)
        db.session.commit()
        return rtoken.refresh_token


  #TODO: The refresh tokens can also or be invalidated, we need to look at there : https://stackoverflow.com/questions/40555855/does-the-refresh-token-expire-and-if-so-when
    def revokeRefreshToken(self, refToken):
        print("IMPLEMENT THIS...")
        return True




class SciTokenServer():

    # NOTE: The ideas behind the separate Validator in this library is taken from libmacaroons.
    def __init__(self, keygen_method, ref_token_url, iss='local'):
        '''
        :param keygen_method: The key generation method that will be used.
        '''
        self.VALIDATE_REFTOKEN_URL = ref_token_url
        if keygen_method == 1:
            self._private_key = self._genKeyPairWithCryptLib()
        elif keygen_method == 2: #TODO : To be implemented
            self._private_key = self._genKeyPairWithOpenSSL(file)
        self.issuer = iss



    def _genKeyPairWithCryptLib(self):
        '''
        Generate private key
        :return:
        '''
        return generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )

    # TODO: This is incomplete.
    # NOTE : https://stackoverflow.com/questions/89228/calling-an-external-command-in-python
    def _genKeyPairWithOpenSSL(self, key_file):
        # call the generate scripts
        p = subprocess.Popen('generate_keys.sh '+key_file, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        for line in p.stdout.readlines():
            print(line)
        #retval = p.wait()



    def generate_scitoken(self, parent_token = None, refresh_token = None, claims = None):
        '''
        @param parent_token: The parent token for the new SciToken.
        @param refresh_token: The refresh token that will be used to generate the Scitoken
        @return: Scitoken
        '''
        # TODO : Python implementation does not support parent tokens (i.e. hierarchies) yet.
        payload = {'refresh_token': refresh_token}
        r = requests.post(self.VALIDATE_REFTOKEN_URL, data=payload, verify=False)
        if r.json()['result']:
            # NOTE : According to Github, the below should "Create token and generate a new private key"
            # but it does not generate a private key and results with MissingKeyException
            # token=scitokens.SciToken()
            token = scitokens.SciToken(key=self._private_key, parent=parent_token)
            token.update_claims(claims)
            serialized_token = token.serialize(issuer = 'local')
            print(serialized_token)
            return token
        else:
            return None



    def revoke_scitoken(self,token):
        # TODO : TO BE IMPLEMENTED
        return False  # self.validator.validate(token)





class SciTokenEnforcer():

    def __init__(self):
        pass

    def enforceToken(self, token, action, resource):
        serialized_token = token.serialize(issuer="local")
        token = scitokens.SciToken.deserialize(serialized_token, public_key=self._public_pem, insecure=True)
        # test whether the token holder is allowed to
        return self.enf.test(token, action, resource)


    ###########################
    ####  ENFORCE SCITOKEN
    ###########################
    # The enforcer object is instantiated with the issuer and it creates a Validator object
    # to which validator functions can be added
    # Similarly, the scope of the enforcer can be narrowed down to a specific audience
    # For instance scitokens.Enforcer("https://scitokens.org/dteam", audience="https://example.com")
    # will accept only the tokens for the requests addressed to services of "https://example.com"
    def generateEnforcer(self, issuer, aud=None, validators = None):
        '''
        Generate an enforcer that will be used for the enforcement of tokens.
        :param issuer: The issuer of the scitokens.
        :return: An enforcer object for the specified issuer.
        '''
        self.enf = scitokens.Enforcer(issuer=issuer, audience=aud)
        for claim, validator in validators:
            self.enf.add_validator(claim, validator)
        return self.enf




    ###########################
    ####  VALIDATE SCITOKEN
    ###########################
    # Validation is determining whether the claims of the token are satisfied in a given context.
    # To validate a specific claim, provide a callback function (below) to the Validator object
    def validate_scp(self,token):
        '''
        :param token: The scitoken to be validated.
        :return: True or False
        '''
        return self.validator.validate(token)


    ###########################
    ####  VERIFY SCITOKEN
    ###########################
    # verification refers to determining the integrity and authenticity of the token:
    # - Can we validate the token came from a known source without tampering?
    # - Can we validate the chain of trust?
    def verify_token(self,token):
        '''
        :param token: The scitoken to be verified : This means that the integrity and authenticity of the token
        will be checked
        :return: True or False
        '''
        return self.validator.validate(token)









########################################################################




    # To validate a specific claim, provide a callback function (below) to the Validator object
    def validate_NEW_CLAIM(value):
        return value == True


    # This is JWT generation taken from Scitoken Github page which is in return taken from Codacy...
    # TBD...
    def generateJWTToken(self):
        SciTokenServer.generateKeyPair(self, "sample_ecdsa_keypair.pem")
        with open("sample_ecdsa_keypair.pem", "r") as file_pointer:
            serialized_pair = file_pointer.read()

        loaded_public_key = serialization.load_pem_public_key(
            serialized_pair,
            backend=default_backend()
        )
        # Generate a scitoken
        token = scitokens.SciToken()
        return token


