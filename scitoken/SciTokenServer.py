import scitokens
import subprocess
import requests
from cryptography.hazmat.primitives.asymmetric.rsa import generate_private_key
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

from scitoken.models import OAuth2RefreshToken, User, db


# NOTES
# The normal flow is the following:
# 1. You generate a base token with generateBaseSciToken() which
#    will generate a Scitoken after generating a private key
# 2. Then generate a normal token by using the relevant base token.
#    Since the tokens can be chained, the relevant permission hierarchies
#    must be taken into consideration...

# Parent Tokens:
# The tokens can also be chained, i.e. one token can be appended to another.
# By default the new token will default to having all the authorisations of the parent token
# but is mutable and can add further restrictions. Parent tokens are typically generated by a
# separate server and sent as a response to a successful authentication or authorization request
#
# Refresh Tokens:
# The generation of the refresh token will be done according to OAuth2 spec : https://tools.ietf.org/html/rfc6749#section-1.5
# We use authlib of Flask for OAuth2 related functionality.
# The flow here is : An authorization code flow is executed to obtain an authorization code. The authorization code
# then is used to get an access + refresh token...




class TokenManager():
    '''
    This class is basically storage facility for refresh tokens and so on, i.e. facilities for the
    scitoken use...
    '''

    # TODO : Check the Scitoken implementation in the coming months to see their RefreshToken feature is implemented
    # TODO : There are different views: refresh tokens never expire or they have an expiry time/date...
    def addRefreshToken(self, username, refresh_token, scope=None,access_token=None,expires_in = None):
        ''' This method adds a refresh token to the DB

        :param username: The identifier for the user.
        :param refresh_token: Refresh token

        The following parameters are imposed by the ORM `OAuth2TokenMixin` taken from the Authlib but they may be
        eliminated with a new mixin...
        :param scope:  The scope for which the refresh token has been issued
        :param access_token: The access token with which the refresh token has been issued
        :param expires_in: The expiry for the access/refresh token
        '''
        rtoken = OAuth2RefreshToken(user_id=User.query.filter_by(username=username).first().username)
        rtoken.refresh_token = refresh_token
        rtoken.scope = scope
        rtoken.access_token = access_token
        rtoken.expires_in = expires_in
        db.session.add(rtoken)
        db.session.commit()




    def revokeRefreshToken(self, refToken):
        '''
            #TODO: The refresh tokens can also or be invalidated, we need to look at there :
            https://stackoverflow.com/questions/40555855/does-the-refresh-token-expire-and-if-so-when
        '''
        raise NotImplementedError()





class SciTokenServer():
    '''
    This is the core class to handle the generation, serialization/deserialization and revocation of scitokens.
    '''

    # NOTE: The ideas behind the separate Validator in this library is taken from libmacaroons.
    def __init__(self, keygen_method, ref_token_url, issuer='https://localhost'):
        '''
        The constructor for the ScitokenServer class

        :param int keygen_method: Key generation method that will be used.
        :param str ref_token_url: Refresh token validation URL
        :param str issuer: Issuer of the "scitoken"
        '''
        self.VALIDATE_REFTOKEN_URL = ref_token_url
        if keygen_method == 1:
            self._private_key = self._genKeyPairWithCryptLib()
            self.public_key_pem = self._private_key.public_key().public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
        elif keygen_method == 2:
            raise NotImplementedError()
            # self._private_key = self._genKeyPairWithOpenSSL(file)
            # self.public_key_pem = None
        self.issuer = issuer



    def _genKeyPairWithCryptLib(self):
        '''
        Generate private key with the cryptography library
        :return: Generates a new 2048 bit RSA private key using the default backend
        :rtype RSAPrivateKey object
        '''
        return generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )



    # def _genKeyPairWithOpenSSL(self, key_file):
    #     # call the generate scripts
    #     p = subprocess.Popen('generate_keys.sh '+key_file, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    #     for line in p.stdout.readlines():
    #         print(line)
    #     #retval = p.wait()



    def generate_scitoken(self, parent_token = None, refresh_token = None, claims = None):
        '''
        This is the principal method that generates a scitoken.
        TODO : Note that Python implementation does not support parent tokens (i.e. hierarchies) yet.

        :param parent_token: Parent token for the new SciToken.
        :param refresh_token: Refresh token that will be used to generate the Scitoken
        :param claims: The set of claims that will added (through update) to the scitoken
        :return: scitoken
        '''
        payload = {'refresh_token': refresh_token}
        r = requests.post(self.VALIDATE_REFTOKEN_URL, data=payload, verify=False)
        if r.json()['result']:
            # NOTE : According to Github, the below should "Create token and generate a new private key"
            # but it does not generate a private key and results with MissingKeyException
            # token=scitokens.SciToken()
            token = scitokens.SciToken(key=self._private_key, parent=parent_token)
            if claims is not None :
                token.update_claims(claims)
            return token
        else:
            return None


    def deserialize(self, serializedtoken):
        '''
        Deserialization of a serialized scitoken. This is decoding of the JWT underlying the
        scitoken.

        :param serializedtoken: Serialized token
        :return: Deserialized token
        '''
        return scitokens.SciToken.deserialize(serialized_token= serializedtoken, public_key=self.public_key_pem)

    def revoke_scitoken(self,token):
        raise NotImplementedError()
        #return False  # self.validator.validate(token)





class SciTokenEnforcer():
    '''
    The class to handle enforcement and validation scitokens.

    The enforcer object is instantiated with the issuer and it creates a Validator object
    to which validator functions can be added. Similarly, the scope of the enforcer can be narrowed
    down to a specific audience. For instance scitokens.Enforcer("https://scitokens.org/dteam", audience="https://example.com")
    will accept only the tokens for the requests addressed to services of "https://example.com"
    '''


    def __init__(self):
        pass


    def generateEnforcer(self, issuer, aud=None, validators = None):
        '''
        Generates a Scitoken enforcer.

        :param issuer: Issuer of the scitokens.
        :param aud: Audience for the scitokens (similar to JWT audience : 'aud' claim identifies the
        recipients that the JWT is intended for)
        :param validators:
        :return: An enforcer object for the specified issuer.
        :rtype: Enforcer object
        '''
        self.enf = scitokens.Enforcer(issuer=issuer, audience=aud)
        if validators is not None:
            for claim, validator in validators:
                self.enf.add_validator(claim, validator)
        return self.enf



    def enforceToken(self, token, action, resource, public_pem):
        '''

        :param token: Scitoken used for access
        :param action: Action to be performed, this needs to be one of the values of the
        'scp' claim (that is {read, write, execute,queue})
        :param resource: Identifier for the protected resource
        :param public_pem: Public key is necessary to deserialize the scitoken before testing
        :return: {True or False}
        :rtype: bool
        '''
        #serialized_token = token.serialize(issuer="local")
        try:
            stoken = scitokens.SciToken.deserialize(token, public_key=public_pem, insecure=True)
            return self.enf.test(stoken, action, resource)
        except:
            return False

        # test whether the token holder is allowed to



    def validate_scp(self,token):
        '''
        Validation is determining whether the claims of the token are satisfied in a given context.
        To validate a specific claim, provide a callback function (see below an example) to the Validator object

        :param token: The scitoken to be validated.
        :return: True or False
        '''
        #Add additional checks here...
        return self.validator.validate(token)


    # def validate_NEW_CLAIM(value):
    #     return value == True


    def verify_token(self,token):
        '''
        Verification refers to determining the integrity and authenticity of the token:
        - Can we validate the token came from a known source without tampering?
        - Can we validate the chain of trust?

        :param token: The scitoken to be verified
        :return: True or False
        '''
        return self.validator.validate(token)

